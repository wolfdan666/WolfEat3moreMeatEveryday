昨晚研究UDP收发消息3小时左右

今天2019年11月20日09:26:02 开始边学边写传文件

2019年11月20日15:43:49 遇到了一个数据传输问题
就是音乐传输端一下就把所有的传送完了，然后接收端没反应过来
然后接收端异常退出，把剩下的数据包当做文本流继续处理了..


2019年11月20日16:54:00 和zy和wyh都交流了一下，发现应该没错啊，为什么不行！


2019年11月20日17:08:48 自闭2小时之后，发现是自己不小心复制了老师的clisock... 那个没有初始化的sock...
竟然也能收到东西...

但是为什么还是不停...

2019年11月20日18:15:18 通过观察发现，永远只有64KB，上网搜索`udp文件传输只能传输64KB?`发现
**双方可以按照一定的格式传输大量的数据，而UDP最大为64K。**

也就是说我的错误就是因为没有准备好管道的出水口的水管，我就打开了水龙头，以至于最终水管中只剩下64K的水了...

**但是又有个问题是 ： 就算是最后的64K，那应该包含我的最后的结束标志buffer啊**

> 可能的猜想是：它最后的水混在了一起...所以找不到最后的一小份水了


所以应该别人的成功的代码都是先让发送端发送文件名过去，然后开始等待数据！

好的，改一下代码，找到错误原因就爽了


2019年11月20日18:50:21 传了359KB...还是漏了很多很多数据 -->  丢包严重
去掉了`fflush(fp)`384KB --> 还是疯狂丢包

```
UDP主要丢包原因：
接收端处理时间过长导致丢包：调用 recvfrom方法接收端收到数据后，处理数据花了一些时间，处理完后再次调用 recvfrom方法，在这二次调用间隔里,发过来的包可能丢失。对于这种情况可以修改接收端，将包接收后存入一个缓冲区，然后迅速返回继续 recvfrom。

发送的包巨大丢包：这种情况需要切割成小包再逐个send。

发送的包频率太快：虽然每个包的大小都小于mtu size 但是频率太快，例如40多个mut size的包连续发送中间不sleep，也有可能导致丢包。

源码
――――――――――――――――
版权声明：本文为CSDN博主「Ni9htMar3」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/Ni9htMar3/article/details/53556279
```

然后我给Sleep(500);睡0.5s发1KB... (总共16k KB，所以大概要 8千秒 -- 133mins)
成功接收了600KB了，所以我决定减少睡眠时间...2.8Ghz的cpu，所以Sleep 1ms都很久了!

但是0.5ms 只收到404KB...

1.5ms,成功收到15640KB.. 但是还是没有停！！！


**2019年11月20日20:55:56 才写完这个实验，大概写了整整有8个多小时吧...太菜了**

傻逼错误：
1. 参数写反了
```cpp
//int flag = fwrite(buffer, nCount, 1, fp);
//int flag = fwrite(buffer, 1, nCount, fp);
int flag = fwrite(buffer, sizeof(char), nCount, fp);
```

2. 不操作\0的话，长度会是最长的长度...,导致结束不掉...
```cpp
sprintf(buffer, "finished");
buffer[strlen(buffer)] = '\0';
```

3. 函数写错
```cpp
//if (strcpy(buffer, "finished") == 0) {
if (strcmp(buffer, "finished") == 0) {
```

4. UDP问答
4.1
根据 UDP 协议，从 UDP 数据包的包头可以看出，UDP 的最大包长度是 2^16-1 个字节。

由于 UDP 包头占 8 个字节，而在 IP 层进行封装后的 IP 包头占去 20 字节，所以这个是 UDP 数据包的最大理论长度是 2^16 - 1 - 8 - 20 = 65507 字节。

同时 UDP 发送缓冲区大小（linux下UDP发送缓冲区大小为：cat /proc/sys/net/core/wmem_default）相关，肯定不能超过缓冲区大小。

4.2
测试发现，如果接受区大小小于数据包长度，那么recvfrom会出错返回 -1
如果在sendto使用strlen(不过对于二进制文件的传送一定要用sizeof)，则可以大大降低出错的概率
