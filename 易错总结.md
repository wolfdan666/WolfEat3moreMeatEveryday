1. `int case = 0;`case是保留字！不能乱用，否则报错
2. **Manacher的p一定是原串的两倍长度啊啊啊**
3.
```cpp
// 2019年5月11日20:14:33发现每一行不是r个，而是c个！！！
            n[i*r+j]···
// 还不如用最简单的num++的形象来积累，不然可能一不下心，显摆行列，结果出错！
            n[i*c+j].x=i;  // 下标是temporary的，所以可以sort掉
            n[i*c+j].y=j;
            n[i*c+j].z=h[i][j];
// 以后尽量用简单方法做事，因为大道至简，而且不会错
            int num = 0;
            n[num].···
            n[num].···
            n[num++].···

```


```cpp
// 2019年5月30日23:17:54 poj3889
输出应该用`printf("%.0f",ans);`保证整数四舍五入精度

不要写`printf("%.0lf",ans);`,因为这个TLE了很久….poj首页有写原因---某个大佬说的，然而我并没有在首页找到
```

```cpp
// 2019年6月1日23:05:35 写poj2018时
// 总是把
-1e10
// 写成
1e-10
// 导致出错
```



`f=0,break; // 这样的是报错的`


```cpp
#include<iostream>  // 这个__gcd比自己实现快很多，很好用---注意处理0,0等特例
#include<algorithm>
int a=__gcd(+/-20,0);   //=+/-20
int b=__gcd(0,0);    // =0
```


```cpp
// 看了大佬的代码，才发现自己错在q可能是除不尽的！ 然后被我int之后就导致了误判，导致cnt值偏大!
// 而第二个大佬之所以能对 `(gcd(i, p) == a) && (lcm(i, p) == b)`  ，是因为其使用了两个判断条件，从而正好满足了  剔除掉除不尽的可能性！
if(tem%p==0)

if(__gcd(p,int(tem/p))==x) cnt++; // 这个就是整个条件满足的整合体，最大公约数满足之后，他们的乘积/最大公约 = 最小公倍必定满足    (int)tem/p可能会先转化，不会是这里wa了吧？
```

```cpp
// 2019年7月8日22:19:24
    sort(a.begin(),a.end(),cop);
// 对vector的排序经常被自己写成数组排序的模式
    sort(b,b+n,cop);
```

```cpp
// 2019年7月8日22点50分  // 记得用  ` & `
        // 这里由于我是第一次大量地使用auto,所以由于不熟悉,导致出了错误,没有用&,导致b数组的值并没有确切被更改,导致出现了ans出现了问题---VScode的debug真香,除了gdb对中文名不友好之外
        for(auto d:b)

// 对了---POJ的G++不支持 for auto...
```

```cpp
priority_queue优先队列使用less 缺省是 最大值在队头top  (缺省是大的优先！) 与sort缺省小值在前正好相反！  我2019年7月9日20:26:55 写poj3190发现自己用错了

前天学了priority_queue 是直接看了别人的代码，果然还是不够熟悉！还是得自己实现一遍  把坑采完
```