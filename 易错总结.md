1. `int case = 0;`case是保留字！不能乱用，否则报错
2. **Manacher的p一定是原串的两倍长度啊啊啊**
3.
```cpp
// 2019年5月11日20:14:33发现每一行不是r个，而是c个！！！
            n[i*r+j]···
// 还不如用最简单的num++的形象来积累，不然可能一不下心，显摆行列，结果出错！
            n[i*c+j].x=i;  // 下标是temporary的，所以可以sort掉
            n[i*c+j].y=j;
            n[i*c+j].z=h[i][j];
// 以后尽量用简单方法做事，因为大道至简，而且不会错
            int num = 0;
            n[num].···
            n[num].···
            n[num++].···

```


```cpp
// 2019年5月30日23:17:54 poj3889
输出应该用`printf("%.0f",ans);`保证整数四舍五入精度

不要写`printf("%.0lf",ans);`,因为这个TLE了很久….poj首页有写原因---某个大佬说的，然而我并没有在首页找到
```

```cpp
// 2019年6月1日23:05:35 写poj2018时
// 总是把
-1e10
// 写成
1e-10
// 导致出错
```



`f=0,break; // 这样的是报错的`


```cpp
#include<iostream>  // 这个__gcd比自己实现快很多，很好用---注意处理0,0等特例
#include<algorithm>
int a=__gcd(+/-20,0);   //=+/-20
int b=__gcd(0,0);    // =0
```


```cpp
// 看了大佬的代码，才发现自己错在q可能是除不尽的！ 然后被我int之后就导致了误判，导致cnt值偏大!
// 而第二个大佬之所以能对 `(gcd(i, p) == a) && (lcm(i, p) == b)`  ，是因为其使用了两个判断条件，从而正好满足了  剔除掉除不尽的可能性！
if(tem%p==0)

if(__gcd(p,int(tem/p))==x) cnt++; // 这个就是整个条件满足的整合体，最大公约数满足之后，他们的乘积/最大公约 = 最小公倍必定满足    (int)tem/p可能会先转化，不会是这里wa了吧？
```