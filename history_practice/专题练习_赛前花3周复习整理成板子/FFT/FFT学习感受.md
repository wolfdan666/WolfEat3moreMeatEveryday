通过用C++实现FFT算法，加深了我对课本上的FFT的理解。
朴素的DFT算法一般使用霍纳法则(见算法导论中文第三版528页)把序列从系数表达式转化为点值表达式，每一个点值都需要O(n)的时间，那么n个点值就会使得算法复杂度达到O(n^2)的复杂度。
然而如果我们通过精心选择“单位复数根”作为求值点，就能将DFT算法加速到O(n*logn)的复杂度

这个极大优化了两个序列的卷积计算，我们可以先使用O(n*logn)的FFT变换(也就是加速的DFT变化)，使得时域本来要花O(n^2)的卷积计算能够在频域使用点值表达式的对点相乘，之后对结果进行IFFT(加速了的IDFT)，从而使得整个计算流程从原来的O(n^2)降到了O(n*log(n)),极大地优化了处理速度，使得信息处理行业得到飞速发展，这也就是算法的魅力