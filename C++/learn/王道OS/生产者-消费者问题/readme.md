生产者和消费者的缓冲区不同于进程通信中的管道

因为管道要写完才能读，读完才能写
但是生产者-消费者却可以在"半杯水"的状态进行读写(当然要多个写进程互斥访问缓冲区)


- 只有缓冲区没满时，生产者才能把产品放入缓冲区，否则必须等待(同步)
- 只有缓冲区不空时，消费者才能从中取出产品，否则必须等待。(同步)
- 缓冲区是临界资源，各进程必须互斥地访问。(互斥)

所以对产品设置一对P,V用来实现生产者和消费者之间的同步关系---满足了前两个的同步关系

再设置一对PV操作是实现各个生产者之间对于缓冲区的互斥访问关系

我觉得只要两对信号量，是因为我把底层P,V中的if判断代码改变了，这样子要自己造一些轮子，过度地耦合业务带来少量的性能提升，其实没有必要，所以还是学习老师，设置3个信号量，这样就很好地利用了现有代码

```cpp
semaphore mutex = 1;
//互斥信号量，实现对缓冲区的互斥访问
semaphore empty = n;
//同步信号量，表示空闲缓冲区的数量
semaphore full = 0;
//同步信号量，表示产品的数量，也即非空缓冲区的数量
```

这里实现互斥的mutex的P操作一定要放在同步的P操作的内嵌层，否则会死锁，因为mutex放外层会发生这种情况: 这边先锁住，发现得不到同步资源产品，结果另一边由于进入不了mutex，无法进去生产，相互等待，造成死锁

V操作顺序影响不是很大，具体根据业务需求决定