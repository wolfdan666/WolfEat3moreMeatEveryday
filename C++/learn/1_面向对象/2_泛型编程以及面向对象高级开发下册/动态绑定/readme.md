## 动态绑定条件
- 动态绑定必须是 **指针调用**
- 必须是upcast(向上转型-基类指针指向派生类)，~~子类可以动态调用父类的函数~~,根据具体是哪个派生类的对象动态调用对应对象的虚函数
- virtual function

---
2020年6月5日20:57:13 复习时添加
多态的概念比较复杂，有多种意义的多态，一个有趣但不严谨的说法是：继承是子类使用父类的方法，而多态则是父类(指针)使用子类的方法。

运行时多态有动态绑定，而编译时多态有泛型编程

---

编译成下面这样子
```cpp
(*(p->vptr)[n])(p);
// or 上下是一样的
(* p->vptr[n] )(p);
// 指针函数，指针数组等也是这个原因，就是*的优先级比 `()` 和 `[]` 的优先级低 ___ 2020年6月5日20:59:13 复习时添加
```

最后的`(p)`是表示this指针

### 一些注意点

用对象调用，而非指针调用的时候是静态绑定的

B继承了A
```cpp
A* pa = new B;
pa->vfunc1();
```
向上转型，new出来是B，但是type是A，所以向上转型

这个向上转型还是有点懵

然后我后面2020年3月26日16:01:09去[专门地学习了一波](https://blog.csdn.net/neve_give_up_dan/article/details/105121373)

得到的结论是因为new出来的是派生类，所以向上转型赋值给基类指针，
所以基类还是可以调用派生类中的函数而不出错

关于向下转型呢,就得看上面的那篇文章了


2020年5月13日13:24:47 复习
2020年6月5日21:00:56 复习
2022年03月06日18:08:48 复习
2022年12月06日10:37:05 复习