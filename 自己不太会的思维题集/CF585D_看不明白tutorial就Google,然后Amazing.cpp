/*
[大佬LIf0703](https://llf0703.com/p/cf-1215.html)

设先手为 AA ，后手为 BB 。并把数列左右两边剩下的空格个数记为 a,ba,b 。

当左右两边都有的时候，BB 就可以复制 AA 的操作。

剩下的操作中可以控制每回合(所以a-b后是要除以2的)的和为 9，如果刚好补完那么后手就能获得胜利，否则先手就可以阻碍后手获胜。

发现大佬的想法总是高屋建瓴!!!
只有我个傻逼想歪了,想着傻逼模拟,然后情况还出错了...

但是还是感觉题解错了,不一定全是0,9的操作啊,可能最后一步是非0,9的操作啊!

当我尝试求出tutorial的反例,然后我失败了
???01?
右边的两个数之和必须是9才有可能B赢!  否则[1-8][10-18]都不行! 因为[1-8]别人取9,[10-18]别人取0!所以delta只有为9的倍数才行!
nb! 所以tutorial没错,只是隐藏了很多信息没有说...还是因为我太菜...

2019年09月26日22:50:42 下面附上自己1-3遍,写了大概3小时的最终代码和言论吧,然后放到自己不太会的思维题集里面

*/

#include <bits/stdc++.h>

using namespace std;

inline int read() {
    char ch = getchar();
    int f = 1, x = 0;
    while (ch < '0' || ch > '9') {
        if (ch == '-') f = -1;
        ch = getchar();
    }
    while (ch >= '0' && ch <= '9') {
        x = x * 10 + ch - '0';
        ch = getchar();
    }
    return f * x;
}

int n;
char s[200005];

signed main() {
    n = read();
    scanf("%s", s + 1);
    int a = 0, b = 0, delta = 0;
    for (int i = 1; i <= n; i++) {
        if ((i << 1) <= n) {
            if (s[i] != '?')
                delta += s[i] - '0';
            else
                a++;
        } else {
            if (s[i] != '?')
                delta -= s[i] - '0';
            else
                b++;
        }
    }
    int cur = ((a - b) >> 1) * 9 + delta;
    if (cur) return 0 & puts("Monocarp");
    return 0 & puts("Bicarp");
}


/*

2019年09月26日11:41:35 开始看题
2019年09月26日11:51:24 去吃饭,边吃边想题
2019年09月26日14:20:40 开始写
2019年09月26日14:46:00 发现自己B的落子没有写好,重改
2019年09月26日14:55:16 发现样例三都错了,输出一下数据
2019年09月26日15:10:24 才交,坑... wa on test 5... 傻逼,写了50mins还wa了,实现速度还是要多多练习!-->以及要多思考!
80
????66??8?0?????0??8?45?328??0?6???121038??????4?17??12847??3??65??6?????2????62

傻逼了,写错了,写得时候分情况讨论没写好,写错了一些,应该简化思路思考成为,M想要数字的abs变大,然后B想要tp为0,这样就会写得更快更好,更不容易出错...

...2019年09月26日15:19:19 发现自己整个思路是错的!
我凭什么要顺序落子!?非循序落子反而能取得更优解!所以思路是错的!重写!

# 题意
- n个数字的车牌,n是偶数(n $/in$ [2,2\*$10^5$])
- 一些车牌偶数个数字被搽除了
- 定义美丽车牌的是` 前n/2个数字的数字和 == 后n/2个数字的数字和 `
- M讨厌美丽车牌,而B喜欢
- 玩一个游戏, M先手改被搽除的数字成为0-9中的一个(直到数字被填完)
- 数字填完是美丽的则 B win,否则 M win
a
# 题解
- 总体来说就是M极力去破坏,然后B极力去维护
- 先计算之前的左右的和值,如果左边大于右边,则是左到右遍历
    - 然后左半边M填9,B填0
    - 右半边M填0,B填9
    - 每次填完之后又要开始计算左右两边的和值
    - 最后一个M判断是否可以填0到9之间的数就行了

- 写到一半发现要特判B的落子,不一定每次都0,9,而是可以让相等的时候直接让相等!
- 这样就不用特判i == sz了...

2019年09月26日15:22:37 
其实根本不用记录什么位置.只要分左右还可以落子的个数以及tp(左边减去右边的差值来判断最优解就行了)

2019年09月26日15:44:51 发现好像有系统的一些原因,导致代码重用有问题..先去上课,等下来测1

玄学,发现测多组的时候有些输入的 答案 可能每次不同! 然后 wa on test 35 , 不折腾了,快点看tutorial!

有一说一,这个题目真的是恶心!

我第三遍写,发现这样贪心最终也是不对的,还是没有考虑到全面的情况!因为有种可能是左边还剩两个??,右边使左右两边差距变成0了...===> 然而实际策略应该是先限制别人,然后自己被限制,然后死掉
*/

/* 
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll mod=1000000007;
const int inf = 0x3f3f3f3f;
inline int rd() {int x=0;char p=getchar();while(p<'0'||p>'9')p=getchar();while(p>='0'&&p<='9')x=x*10+p-'0',p=getchar();return x;}
const int M = 2e5+5;
int n,tp,cnt1,cnt2,sum;
char s[M];

int main(){
	while(~scanf("%d",&n)){
		scanf("%s",s+1);

		for(int i=1;i<=n;i++){
			if(s[i]!='?') tp = i<=n/2 ? tp+s[i]-'0' : tp-(s[i]-'0');
			else{
				if(i<=n/2) cnt1++;
				else cnt2++;
			}
		}
		
		sum = cnt1 + cnt2;
		if(sum){
			for(int i=1;i<=sum;i++){
				if(tp>=0){
					if(i&1){
						if(cnt1) tp+=9,cnt1--;
						// 左边不能变大,那我可以阻止右边变大!
						else cnt2--;
					} else {
						if(cnt2) if(tp<=9) tp=0,cnt2--;else tp-=9,cnt2--;
						// 右边不能变大了,不能缩小tp了,那我也不让你左边再变大
						else cnt1--;
					}
				} else {
					if(i&1){
						if(cnt2) tp-=9,cnt2--;
						else cnt1--;
					} else {
						if(cnt1) if(tp>=-9) tp=0,cnt1--;else tp+=9,cnt1--;
						else cnt2--;
					}
				}
			}
		}
		printf("%s\n",tp ? "Monocarp" : "Bicarp" );		
	}	 

    return 0;
} */