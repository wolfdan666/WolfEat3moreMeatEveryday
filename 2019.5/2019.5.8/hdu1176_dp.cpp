// 2019年5月8日12:56:23 开始番茄时钟   开始看题

// 感觉跟昨天的那个作业题很像，但是又只能想到递归...可以先去学习一下dp再来写了，好的，先去学习吧
// 不行啊，刷题期间先别看书，刷完题之后在专门看书的时候再看书，所以先看看大佬怎么写
// 两个番茄时间才看完一题，坑啊

/*
乍一看和塔数很像（http://www.cnblogs.com/sjy123/p/3241995.html），其实就是很像，一个升级版的塔数。

-----------------------------------------------分割线--------------------------------------------------

         5                         t=0
        456                        t=1
       34567                       t=2
      2345678                      t=3
     123456789                     t=4
    012345678910                   t=5
    012345678910                   t=6

总体来说，这道题就是上面这样的塔数，很明显，第i层的0只能从上一层的0，1中最大的来，倒推的话，也是一样的，第i层的0也只能由下一层的0，1来，（t=5之前实际没有0，因为走不到那，但是我们可以假设有），同理，每行的10也只能有下一行9，10推出来。

-----------------------------------------------分割线------------------------------------------------

要倒推，要不然没法到达0,5这个点，因为最后需要从0,5出发的
---------------------
作者：蜗牛蜗牛慢慢爬
原文：https://blog.csdn.net/u014665013/article/details/70214500

*/



#include <bits/stdc++.h>
#define MAXN 100010
using namespace std;

int dp[MAXN][12],pile[MAXN][12];
///全局变量和静态变量的存储区域是在一起的，程序结束后由系统释放。数据区的大小由系统限定，一般很大。
int max_is(int a,int b,int c);
int main(){
    int n,x,t,i,j,maxt;
    while(scanf("%d",&n)!=EOF&&n){
        memset(dp,0,sizeof(dp));
        memset(pile,0,sizeof(pile));
        maxt=0;
        for(i=0;i<n;i++){
            scanf("%d%d",&x,&t);
            pile[t][x]++;  //// 每个时间点的饼数
            if(maxt<t) maxt=t;
        }
        // for(i=1;i<=11;i++) // 这里博主应该是写错了的，在maxt应该是有0位置的馅饼的，不过因为数据水了，让博主没发现这里
        for(i=0;i<=10;i++)  //就改了这里，时间减少了30ms，我惊了
            dp[maxt][i]=pile[maxt][i];
        for(i=maxt-1;i>=0;i--){
// 很明显，这里的dp是自底向上的，所以需要初始化最开始的dp[max][...]，
// 所以在dp的时候肯定是从max-1开始，因为dp[max][...]的已经被初始化了
            for(j=0;j<11;j++){  // 0到10 这11个位置
                if(j==0) dp[i][j]=max(dp[i+1][j],dp[i+1][j+1])+pile[i][j];
                else dp[i][j]=max_is(dp[i+1][j-1],dp[i+1][j],dp[i+1][j+1])+pile[i][j];  // j+1等于11的时候没有关系的,max不会取到0
            }
        }
        printf("%d\n",dp[0][5]);
    }
    return 0;
}
int max_is(int a,int b,int c){
    return max(a,max(b,c));
}